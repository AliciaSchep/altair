---
title: "Field Guide to Python Issues"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
editor_options:
  chunk_output_type: inline
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

There are four foundations upon which this package rests: 

- the [Altair](https://altair-viz.github.io/) Python package, to build chart specifications
- the [reticulate](https://rstudio.github.io/reticulate/index.html) R package, to provide inter-operability with Python
- the [Vega-Lite](https://vega.github.io/vega-lite/) JavaScript framework, to render chart specifications in an HTML file.
- the [htmlwidgets](https://www.htmlwidgets.org/) R package, to provide inter-operability with HTML and JavaScript

This article deals with the first two items; the [chart-rendering article](field-guide-rendering.html) deals with the other two.

The purpose of this document is to try to collect in one place, in a semi-organized fashion, all the fiddly-bits we have found dealing with Python stuff. If you get a cryptic Python error, check here. If you find a workaround for something that isn't here, please let us know!

## Overview

Here's the short version. When referring to the Altair documentation:

- Where you see a `.`, use a `$` instead.

- Altair *methods* return a copy of the object. Assignment of a Python object returns a refrence, not a copy. To get the behavior you might be accustomed-to for assignment of "bare" objects, use a `$copy()` method.

- If you have a dataset that has variables with dots in their names, e.g. `Sepal.Width`, you have to make some accomodation when referring to such names in Altiar. As a workaround, you can use square-brackets to refer to "[Sepal.Width]".

- There is an Altair Chart method called `repeat()`; in R `repeat`, is a reserved word, so it needs to be enclosed in backticks: ``$`repeat`()``. 

- Where you see an inversion operator, `~`, like `~highlight`, in Altair examples, call the method explicitly from R: ``hightlight$`__invert__`()``. 

- Where you see a hyphen in the name of a Python object, use an underscore in R: `vega_data$sf_temps()`

- Where you see `["foo", "bar"]` in Altair examples, use an unnamed list in R: `list("foo", "bar")`. Where you see `{'a' = "foo", 'b' = "bar"}` in Altair examples, use a named list in R: `list(a = "foo", b = "bar")`

## Method chaining

## Copy on modify, reference on assignment

## Dots in variable names

If your encoding variables have dots in them, enclose their names in square-brackets. This has the side effect of showing the brackets in the scale labels. (TODO: find the references to this and the `\\` workaround identfied by Alicia) 

```{r iris}
chart_iris <- 
  alt$Chart(r_to_py(iris))$
  encode(
    x = "[Sepal.Width]:Q",
    y = "[Sepal.Length]:Q",
    color = "Species:N"
  )$
  mark_point()

chart_iris
```

## Repeat

## Inversion (`~`)

## Hyphens in Python Names

## Lists and Dictionaries

When **reticulate** returns a Python object with a custom class, it appears in R as an S3 object that *behaves* like a reference class. This means that if you see this sort of notation in Python:

```python
# Python
foo.bar()
```

You would use this notation in R:

```r
foo$bar()
```

In essence, you wherever you see a `.` in Python, use a `$` in R.

### Altair object

In Python, Altair methods return a copy of the object:

```{r}
library("altair")
library("pryr")

vega_data <- import_vega_data()

chart_old <-
  alt$Chart(
    r_to_py(vega_data$cars())
  )$encode(
    x = "Miles_per_Gallon:Q",
    y = "Horsepower:Q",
    color = "Origin:N"
  )

chart_new <- chart_old$mark_point()

address(chart_new) == address(chart_old)
```
To confirm this we note that the two charts have different memory addresses. This suggests that Altair methods return a copy of the object; it *looks* like a reference-class method, but it *acts* like an S3 method.

Let's try an assignment:

```{r}
chart_new <- chart_old

address(chart_new) == address(chart_old)
```

It seems that an assignment of an Altair object (and perhaps, by extension, Pyhton objects) returns a reference, rather than a copy. To return a copy of the object, use a copy method.

```{r}
chart_new <- chart_old$copy()

address(chart_new) == address(chart_old)
```




